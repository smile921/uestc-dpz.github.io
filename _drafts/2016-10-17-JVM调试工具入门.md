---
layout    : post
title     : JVM调试工具入门
date      : 2016-10-17
author    : Smile
categories: blog
tags      : Java
image     : /assets/article\_images/2016-09-25.jpg
---
_ 「jstat,  jmap, jstack」_

上周末连续两天凌晨都收到了系统的内存使用率过高报警，在分析监控系统记录的内存使用率曲线和内存使用情况后发现，主要是因为在老年代迟迟没有触发full gc导致监控系统连续多次监测到可用内存过低，而触发的报警。在系统触发一次full gc之后，内存使用率会显著下降，报警也没有持续下去。由于无法复现问题，具体原因仍未找到，但是通过此过程，学习到的内存分析工具与方法，却值得记录一番。

### jstat
> The jstat tool displays performance statistics for an instrumented HotSpot Java virtual machine (JVM).

jstat是HotSpot Java虚拟机的性能统计工具。其基本的语法描述如下：
    jstat [generalOption | outputOptions | vmid [interval[s|ms] [count]]]

### generalOption
generalOption是针对jstat功能的描述，包括两个参数_-help_ 与_-options_，分别用于提示jstat的用法和支持的统计选项。该选项具有排他性，只能单独使用。

### outputOptions
outputOptions包括两类参数：_状态统计_和_格式化输出_。状态统计参数用于指定jstat命令希望获取虚拟机哪方面的信息，而格式化参数则用于控制命令输出的展示样式。  

jstat支持的状态统计参数（即jstat -options的输出）及功能描述如下:
    -class				统计类加载行为
    -complier			统计HotSpot即时编译器的行为
    -gc					统计关于堆内存垃圾回收的行为
    -gccapacity 		统计堆内存中各分区的使用情况
    -gccause			垃圾回收行为汇总，比-gcutil多输出最近两次垃圾回收的原因
    -gcnew,-gcold		新生代，老年代行为信息（内存量，阈值，垃圾回收次数等）
    -gcnewcapacity		新生代内存容量和使用量信息
    -gcoldcapacity 		老年代内存容量和使用量信息
    -gcpermcapacity		持久区内存容量和使用量信息
    -gcutil 			垃圾回收行为汇总
    -printcompilation 	HotSpot编译方法统计

格式化参数包括三个：_-h n_，_t_和_-JjavaOption_. -h参数指定每隔n行重新显示一次列名;-t参数控制在输出第一列添加时间戳信息;-JjavaOption用于传递javaOption到java程序启动参数。比如，-J-Xms48m 设置java启动最小内存为48M。

### vmid
>Virtual machine identifier, a string indicating the target Java virtual machine (JVM). 
vmid是待监测的目标java程序标识符，可用_jps_和Linux系统下的_ps_等操作获取。vmid参数也支持以URI形式指定的远程主机上运行的java程序，不常用，不再赘述。

### interval and count
这两个参数用于控制jstat命令监测并输出的频率，interval默认参数为毫秒，如果设置了该参数，jstat命令将每隔interval的时间输出一次，count控制jstat命令输出样例的个数，也就是输出的行数。如果不设置，默认为无限，jstat会一直进行输出直到目标程序退出或者jstat命令终止。

### 样例


##jstack

jstack用于打印指定java进程或者核心文件中所有java线程当前时刻正在执行的方法堆栈追踪情况，也就是线程的snapshot。生成线程的快照主要用于定位线程长时间出现停顿的原因：如死锁，等待外部资源等。jstack的命令格式如下：
    jstack [option] pid/executable core/[server-id@]remote-hostname-or-IP

- pid
待追踪的java进程ID，可使用jps等方式获得
- executable
产生core dump的java可执行程序(jar文件)
- core
打印栈追踪信息的核心文件

### options
    -F      当正常输出的请求(jstack [-l] pid)不被响应时，强制执行stack dump
    -l 		除了堆栈外，打印关于锁的附加信息
    -m 		如果调用本地方法，同时打印java和本地C/C++栈帧
    -h 		打印帮助

### 样例

##jmap

jmap用于生成java进程的heapdump或者堆内存的详细信息。可以用来分析java程序堆内存被各种实例占据的比例或者GC回收了哪些对象等信息。jmap的命令格式与jstack一致，不再赘述。

### options
   <no option> 								打印每一个共享对象的起始地址，范围等信息
   -dump:[live,]format=b,file=<filename> 	以二进制形式打印java堆的dump信息到指定文件中，指定live参数，只打印存活的对象
   -heap 									显示java堆的详细信息：GC算法，堆配置以及分代情况
   -histo[:live] 							显示堆中每一个java类实例的个数，占据空间的大小，类名全称等。live参数控制输出存活对象。
   -premstat 								以classLoader为统计入口，显示永久代的生存状态。每个加载器的名称，存活状态，地址，父加载器和已经加载类的数量等信息将被打印。
   -F 										在正常的命令对-dump或者-histo没有响应时，强制执行，生成dump信息
   -J<flag> 								jmap启动时传递给jvm的参数，比如在64位机器上就要使用jmap -J-d64 -heap pid来执行命令。
—
### 参考链接
1. [http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html][1]
2. [http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html][2]
3. [http://docs.oracle.com/javase/7/docs/technotes/tools/share/jmap.html][3]
4. [https://my.oschina.net/feichexia/blog/196575][4]
5. [http://go-on.iteye.com/blog/1673894][5]